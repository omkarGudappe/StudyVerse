plvq yole vjpe jlrx 




import React, { useState, useRef } from 'react'

import { motion, AnimatePresence } from 'framer-motion'

import axios from 'axios';

import { auth } from '../../Auth/AuthProviders/FirebaseSDK';

import Socket from '../../SocketConnection/Socket';

import { usePostsStore } from '../../StateManagement/StoreNotes';



const Post = ({ ModelCloseClicked }) => {

    const [Selected, setSelected] = useState(false);

    const [preview, setPreview] = useState(null);

    const [isDragging, setIsDragging] = useState(false);

    const [Loading, setLoading] = useState(false);

    const [Percent, setPercent] = useState(0);

    const [page, setPage] = useState(0);

    const [uploadStatus, setUploadStatus] = useState('idle');

    const [error, setError] = useState(null);

    const [PostDetail, setPostDetail] = useState({

        heading: "",

        description: "",

        image: "",

        visibility: "",

    })

    const [PostContent, setPostContent] = useState("");

    const cancelRequest = useRef(null);

    const { addPost } = usePostsStore();

    const [uploadPhase, setUploadPhase] = useState('');



    const variants = {

        enter: (direction) => ({

            x: direction > 0 ? "100%" : "-100%",

            opacity: 0,

            scale: 0.95

        }),

        center: {

            x: 0,

            opacity: 1,

            scale: 1

        },

        exit: (direction) => ({

            x: direction < 0 ? "100%" : "-100%",

            opacity: 0,

            scale: 0.95

        }),

    };



    const [direction, setDirection] = useState(0);



    const contentTypes = [

        {

            type: "post",

            label: "Post",

            icon: (

                <svg xmlns="http://www.w3.org/2000/svg" className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />

                </svg>

            ),

            description: "Share images and photos",

            color: "from-blue-500 to-cyan-500"

        },

        {

            type: "lesson",

            label: "Lesson",

            icon: (

                <svg xmlns="http://www.w3.org/2000/svg" className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />

                </svg>

            ),

            description: "Upload educational videos",

            color: "from-purple-500 to-pink-500"

        },

        {

            type: "note",

            label: "Notes",

            icon: (

                <svg xmlns="http://www.w3.org/2000/svg" className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />

                </svg>

            ),

            description: "Share study materials",

            color: "from-amber-500 to-orange-500"

        }

    ];



    const handleFileChange = (e) => {

        if (e.target.name === 'image') {

            const selectedFile = e.target.files[0];

            if (!selectedFile) return;

            

            const validTypes = {

                post: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],

                lesson: ['video/mp4', 'video/webm', 'video/ogg', 'video/quicktime', 'video/x-m4v'],

                note: ['application/pdf', 'text/plain', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']

            };



            // Check if file type is valid

            if (!validTypes[PostContent]?.includes(selectedFile.type)) {

                setError(`Please select a valid ${PostContent} file type. Got: ${selectedFile.type}`);

                return;

            }



            // Check file size limits

            const fileSizeInMB = selectedFile.size / (1024 * 1024);

            

            if (PostContent === 'lesson' && fileSizeInMB > 100) {

                setError(`Video files must be less than 100MB. Your file is ${fileSizeInMB.toFixed(2)}MB.`);

                return;

            }

            

            if (PostContent === 'post' && fileSizeInMB > 10) {

                setError(`Image files must be less than 10MB. Your file is ${fileSizeInMB.toFixed(2)}MB.`);

                return;

            }

            

            if (PostContent === 'note' && fileSizeInMB > 5) {

                setError(`Document files must be less than 5MB. Your file is ${fileSizeInMB.toFixed(2)}MB.`);

                return;

            }



            setSelected(selectedFile);

            setPreview(URL.createObjectURL(selectedFile));

            setPostDetail((prev) => ({ ...prev, image: selectedFile }));

            setError(null);

        } else {

            setPostDetail((prev) => ({ ...prev, [e.target.name]: e.target.value }));

        }

    };



    const handleDragOver = (e) => {

        e.preventDefault();

        setIsDragging(true);

    }



    const handleDragLeave = (e) => {

        e.preventDefault();

        setIsDragging(false);

    }



    const handleDrop = (e) => {

        e.preventDefault();

        setIsDragging(false);

        

        const files = e.dataTransfer.files;

        if (files.length > 0) {

            handleFileChange({ target: { name: 'image', files: [files[0]] } });

        }

    }



    React.useEffect(() => {

        if (error) {

            const timer = setTimeout(() => {

                setError(null);

            }, 9000);

            return () => clearTimeout(timer);

        }

    }, [error]);



  // Add this useEffect for Socket.IO progress tracking

// Update your useEffect socket listener

React.useEffect(() => {

  const handleUploadProgress = (data) => {

    console.log('ðŸ“¡ Progress update received:', data);

    

    let calculatedPercent = 0;

    

    // Fix the progress mapping logic

    switch (data.phase) {

      case 'processing':

        // 100 from backend = 10% in frontend

        calculatedPercent = 10;

        break;

      case 'analyzing':

        // 100 from backend = 20% in frontend  

        calculatedPercent = 20;

        break;

      case 'compressing':

        // Backend sends 100-200, map to 20-70% in frontend

        // data.progress ranges from 100 to 200

        const compressionRange = data.progress - 100; // 0 to 100

        calculatedPercent = 20 + (compressionRange * 0.5); // 20% to 70%

        break;

      case 'uploading_to_cdn':

        // Backend sends 200, map to 70-95% in frontend

        calculatedPercent = 70;

        break;

      case 'complete':

        calculatedPercent = 100;

        setUploadStatus('success');

        setLoading(false);

        // Leave room on completion

        const Fid = auth.currentUser.uid;

        Socket.emit('leaveUploadRoom', Fid);

        break;

      case 'error':

        setError(data.message || 'Upload failed');

        setUploadStatus('error');

        setLoading(false);

        // Leave room on error

        const FidError = auth.currentUser.uid;

        Socket.emit('leaveUploadRoom', FidError);

        return;

      default:

        // Fallback: if backend sends direct percentage

        calculatedPercent = Math.min(data.progress, 100);

    }

    

    // Ensure we don't go over 100%

    calculatedPercent = Math.min(Math.round(calculatedPercent), 100);

    

    console.log(`ðŸ“¡ Mapping: backend ${data.progress} (${data.phase}) â†’ frontend ${calculatedPercent}%`);

    

    setPercent(calculatedPercent);

    setUploadPhase(data.phase);

    

    if (data.message) {

      console.log('ðŸ“¡ Progress message:', data.message);

    }

  };



  const handleUploadError = (error) => {

    console.error('ðŸ“¡ Upload error received:', error);

    setError(error.message || 'Upload failed');

    setUploadStatus('error');

    setLoading(false);

  };



  // Listen for progress updates

  console.log('ðŸ“¡ Setting up socket listeners for uploadProgress');

  Socket.on('uploadProgress', handleUploadProgress);

  Socket.on('uploadError', handleUploadError);



  return () => {

    console.log('ðŸ“¡ Cleaning up socket listeners');

    Socket.off('uploadProgress', handleUploadProgress);

    Socket.off('uploadError', handleUploadError);

  };

}, []);



const handleSubmit = async () => {

  if (!PostDetail.heading.trim()) {

    setError("Please add a title for your content");

    return;

  }

  

  if (!PostDetail.visibility) {

    setError("Please select a visibility option");

    return;

  }



  const form = new FormData();

  const Fid = auth.currentUser.uid;

  form.append('heading', PostDetail.heading.trim());

  form.append('description', PostDetail.description.trim());

  form.append('image', PostDetail.image);

  form.append('contentType', PostContent);

  form.append('visibility', PostDetail.visibility);



  setLoading(true);

  setUploadStatus('uploading');

  setPercent(0);

  setUploadPhase('preparing');



  try {

    cancelRequest.current = axios.CancelToken.source();



    // Join user's room for progress updates

    Socket.emit('joinUploadRoom', Fid);



    // Remove the fake progress - real progress will come from WebSocket

    setUploadPhase('uploading');



    const res = await axios.post(`${import.meta.env.VITE_API_URL}/user/posts/${Fid}`, form, {

      headers: { "Content-Type": "multipart/form-data" },

      cancelToken: cancelRequest.current.token,

      onUploadProgress: (progressEvent) => {

        if (progressEvent.total) {

          // Only track upload progress up to 30% (compression will take the rest)

          const uploadProgress = Math.round((progressEvent.loaded * 30) / progressEvent.total);

          setPercent(uploadProgress);

        }

      },

      timeout: 300000, // 5 minute timeout for large uploads

    });



    const result = res.data;

    if (result && result.newPost) {

      // Success is now handled by WebSocket 'complete' phase

      addPost(result.newPost);

      console.log(result.uploadFile, "for checking url");

      Socket.emit("NewPostUploded", { upload: true });

      setTimeout(() => ModelCloseClicked(false), 1500);

    } else {

      throw new Error(result.message || "Failed to upload");

    }

  } catch (err) {

    if (axios.isCancel(err)) {

      setUploadStatus('idle');

      setError("Upload cancelled");

    } else if (err.code === 'ECONNABORTED') {

      setError("Upload timed out. Please try again with a smaller file or better connection.");

      setUploadStatus('error');

    } else if (err.response) {

      // Server responded with error status

      const status = err.response.status;

      const message = err.response.data?.message || "Upload failed";

      

      switch (status) {

        case 400:

          setError(message || "Missing required fields");

          break;

        case 401:

          setError("Please log in again to upload content");

          break;

        case 403:

          setError("You don't have permission to upload content");

          break;

        case 404:

          setError("User not found. Please check your account");

          break;

        case 413:

          setError("File too large. Please choose a smaller file");

          break;

        case 415:

          setError("Unsupported file type");

          break;

        case 500:

        case 502:

        case 503:

          setError("Server error. Please try again later");

          break;

        default:

          setError(message || "Upload failed. Please try again.");

      }

      setUploadStatus('error');

    } else if (err.request) {

      // Network error

      setError("Network error. Please check your connection and try again.");

      setUploadStatus('error');

    } else {

      // Other errors

      setError(err.message || "An unexpected error occurred");

      setUploadStatus('error');

    }

    setLoading(false);

  }

};



    const handleCheckSelectedData = () => {

        if (!Selected) {

            setError("Please select content to share");

            return;

        }

        navigateTo(2);

    }



    const handleCancelUpload = () => {

        if (cancelRequest.current) {

            cancelRequest.current.cancel("Upload cancelled by user");

        }

        setUploadStatus('idle');

        setLoading(false);

        setPercent(0);

        setUploadPhase('');

    }



    const handleCancel = () => {

        if (uploadStatus === 'uploading' && cancelRequest.current) {

            cancelRequest.current.cancel("Upload cancelled by user");

        }

        

        setSelected(false);

        setPostDetail({

            heading: "",

            description: "",

            image: "",

            visibility: "",

        });

        setPreview(null);

        setUploadStatus('idle');

        setPercent(0);

        setPage(0);

        setError(null);

        setUploadPhase('');

    }



    const navigateTo = (newPage) => {

        setDirection(newPage > page ? 1 : -1);

        setPage(newPage);

    }



    const formatFileSize = (bytes) => {

        if (bytes === 0) return '0 Bytes';

        const k = 1024;

        const sizes = ['Bytes', 'KB', 'MB', 'GB'];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];

    };



    return (

        <div className='fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4'>

            <motion.div 

                initial={{ opacity: 0, scale: 0.9 }}

                animate={{ opacity: 1, scale: 1 }}

                exit={{ opacity: 0, scale: 0.9 }}

                className='relative lenis bg-neutral-900 rounded-3xl w-full max-w-2xl max-h-[80vh] overflow-y-auto shadow-2xl border border-neutral-700'

                onClick={(e) => e.stopPropagation()}

            >

                <div className='flex items-center justify-between p-6 border-b border-neutral-700 bg-neutral-800/50'>

                    <h2 className='text-xl font-bold text-white'>

                        {page === 0 ? 'Create New Post' : page === 1 ? 'Add Content' : 'Final Details'}

                    </h2>

                    <button 

                        className='p-2 hover:bg-neutral-700 rounded-full transition-colors duration-200'

                        onClick={ModelCloseClicked}

                        disabled={uploadStatus === 'uploading'}

                    >

                        <svg xmlns="http://www.w3.org/2000/svg" className="w-5 h-5 text-neutral-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />

                        </svg>

                    </button>

                </div>



                <div className='w-full bg-neutral-800 h-1'>

                    <motion.div 

                        className='bg-gradient-to-r from-blue-500 to-purple-500 h-full'

                        initial={{ width: '0%' }}

                        animate={{ width: `${(page / 2) * 100}%` }}

                        transition={{ duration: 0.3 }}

                    />

                </div>



                <AnimatePresence mode="wait" custom={direction}>

                    {page === 0 && (

                        <motion.div

                            key="page1"

                            custom={direction}

                            variants={variants}

                            initial="enter"

                            animate="center"

                            exit="exit"

                            transition={{ duration: 0.3, ease: "easeInOut" }}

                            className='p-6'

                        >

                            <div className='text-center mb-8'>

                                <h3 className='text-2xl font-bold text-white mb-3'>What would you like to share?</h3>

                                <p className='text-neutral-400'>Choose the type of content you want to post</p>

                            </div>



                            <div className='grid grid-cols-1 md:grid-cols-3 gap-4 mb-8'>

                                {contentTypes.map((content) => (

                                    <motion.button

                                        key={content.type}

                                        whileHover={{ scale: 1.02 }}

                                        whileTap={{ scale: 0.98 }}

                                        onClick={() => {

                                            setPostContent(content.type);

                                            navigateTo(1);

                                        }}

                                        className={`p-6 rounded-2xl border-2 border-neutral-700 bg-neutral-800/50 hover:border-${content.color.split('-')[1]}-500 transition-all duration-300 group`}

                                    >

                                        <div className={`w-16 h-16 rounded-full bg-gradient-to-r ${content.color} flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform duration-300`}>

                                            {content.icon}

                                        </div>

                                        <h4 className='text-white font-semibold text-center mb-2'>{content.label}</h4>

                                        <p className='text-neutral-400 text-sm text-center'>{content.description}</p>

                                    </motion.button>

                                ))}

                            </div>

                        </motion.div>

                    )}



                    {page === 1 && (

                        <motion.div 

                            key="page2"

                            custom={direction}

                            variants={variants}

                            initial="enter"

                            animate="center"

                            exit="exit"

                            transition={{ duration: 0.3, ease: "easeInOut" }}

                            className='p-6 h-auto'

                        >

                            <div className='text-center mb-6'>

                                <h3 className='text-xl font-bold text-white mb-2'>Add Your Content</h3>

                                <p className='text-neutral-400'>Upload your {PostContent} file</p>

                            </div>



                            <div className='mb-6'>

                                {preview ? (

                                    <motion.div 

                                        initial={{ opacity: 0, scale: 0.9 }}

                                        animate={{ opacity: 1, scale: 1 }}

                                        className="bg-neutral-800 rounded-2xl p-4 border border-neutral-700"

                                    >

                                        <div className="relative">

                                            {Selected.type.startsWith("image/") && (

                                                <img

                                                    src={preview}

                                                    alt="Preview"

                                                    className="w-full h-64 object-cover rounded-xl"

                                                />

                                            )}

                                            {Selected.type.startsWith("video/") && (

                                                <video

                                                    src={preview}

                                                    controls

                                                    className="w-full h-64 object-cover rounded-xl"

                                                />

                                            )}

                                            {Selected.type === "application/pdf" && (

                                                <div className="w-full h-64 bg-neutral-700 rounded-xl flex items-center justify-center">

                                                    <div className="text-center">

                                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mx-auto text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />

                                                        </svg>

                                                        <p className="mt-2 text-white font-medium">{Selected.name}</p>

                                                    </div>

                                                </div>

                                            )}

                                            <button

                                                onClick={() => {

                                                    setSelected(false);

                                                    setPreview(null);

                                                }}

                                                className="absolute top-2 right-2 p-2 bg-black/50 rounded-full hover:bg-black/70 transition-colors"

                                            >

                                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />

                                                </svg>

                                            </button>

                                        </div>



                                        <div className="mt-4 p-3 bg-neutral-700/30 rounded-lg">

                                            <p className="text-sm text-neutral-300 mb-2">File details:</p>

                                            <div className="text-xs text-neutral-400 space-y-1">

                                                <p>Name: <span className="text-neutral-300">{Selected.name}</span></p>

                                                <p>Type: <span className="text-neutral-300">{Selected.type}</span></p>

                                                <p>Size: <span className="text-neutral-300">{formatFileSize(Selected.size)}</span></p>

                                            </div>

                                        </div>

                                    </motion.div>

                                ) : (

                                    <motion.div 

                                        whileHover={{ scale: 1.02 }}

                                        className={`border-2 border-dashed rounded-2xl p-8 text-center transition-all duration-300 cursor-pointer

                                            ${isDragging ? 'border-blue-500 bg-blue-500/10' : 'border-neutral-600 hover:border-neutral-500 bg-neutral-800/50'}`}

                                        onDragOver={handleDragOver}

                                        onDragLeave={handleDragLeave}

                                        onDrop={handleDrop}

                                        onClick={() => document.getElementById('fileInput').click()}

                                    >

                                        <div className="flex flex-col items-center justify-center space-y-4">

                                            <div className="p-4 bg-neutral-700/30 rounded-full">

                                                <svg xmlns="http://www.w3.org/2000/svg" className="w-12 h-12 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />

                                                </svg>

                                            </div>

                                            

                                            <div>

                                                <h3 className="text-lg font-medium text-white mb-2">Drop your file here</h3>

                                                <p className="text-neutral-400 text-sm">or click to browse files</p>

                                                <p className="text-xs text-neutral-500 mt-2">

                                                    {PostContent === "post" ? "JPG, PNG, GIF, WEBP (Max 10MB)" : 

                                                     PostContent === "lesson" ? "MP4, WEBM, OGG (Max 100MB)" : 

                                                     "PDF, TXT, DOC, DOCX (Max 5MB)"}

                                                </p>

                                            </div>

                                        </div>

                                        <input 

                                            type="file" 

                                            onChange={handleFileChange}

                                            id='fileInput'

                                            name='image'

                                            accept={PostContent === "post" ? 'image/*' : PostContent === "lesson" ? "video/*" : '.pdf,.txt,.doc,.docx'}

                                            className='hidden' 

                                        />

                                    </motion.div>

                                )}

                            </div>



                            {error && (

                                <motion.div 

                                    initial={{ opacity: 0, y: -10 }}

                                    animate={{ opacity: 1, y: 0 }}

                                    className="bg-red-500/10 border border-red-500/30 rounded-lg p-3 mb-4"

                                >

                                    <p className="text-red-400 text-sm">{error}</p>

                                </motion.div>

                            )}



                            <div className='flex flex-col sm:flex-row gap-3 justify-center'>

                                <motion.button 

                                    whileHover={{ scale: 1.02 }}

                                    whileTap={{ scale: 0.98 }}

                                    className='px-6 py-3 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-semibold rounded-full transition-all duration-300 w-full sm:w-auto flex items-center justify-center gap-2'

                                    onClick={handleCheckSelectedData}

                                    disabled={!Selected}

                                >

                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">

                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />

                                    </svg>

                                    Continue

                                </motion.button>

                                <button 

                                    className='px-6 py-3 bg-neutral-700 hover:bg-neutral-600 text-white font-medium rounded-full transition-colors w-full sm:w-auto'

                                    onClick={() => navigateTo(0)}

                                >

                                    Back

                                </button>

                            </div>

                        </motion.div>

                    )}



                    {page === 2 && (

                        <motion.div

                            key="page3"

                            custom={direction}

                            variants={variants}

                            initial="enter"

                            animate="center"

                            exit="exit"

                            transition={{ duration: 0.3, ease: "easeInOut" }}

                            className="p-6"

                        >

                            <div className='text-center mb-6'>

                                <h3 className='text-xl font-bold text-white mb-2'>Final Details</h3>

                                <p className='text-neutral-400'>Add some information about your content</p>

                            </div>



                            {uploadStatus === 'uploading' && (

                                <motion.div 

                                    initial={{ opacity: 0, y: 20 }}

                                    animate={{ opacity: 1, y: 0 }}

                                    className="bg-neutral-800 p-4 rounded-xl border border-neutral-700 mb-6"

                                >

                                    <div className="flex justify-between items-center mb-3">

                                    <div>

                                        <span className="text-white text-sm font-medium block capitalize">

                                        {uploadPhase.replace(/_/g, ' ')}

                                        {uploadPhase === 'compressing' && ' video'}

                                        </span>

                                        <span className="text-blue-500 text-xs">

                                        {uploadPhase === 'compressing' && Selected ? 

                                        `Compressing ${formatFileSize(Selected.size)} - ${Percent}%` : 

                                        uploadPhase === 'uploading_to_cdn' ? 'Uploading to cloud storage...' :

                                        ''}

                                        </span>

                                    </div>

                                    <span className="text-blue-500 text-sm font-bold">{Percent}%</span>

                                    </div>

                                    

                                    <div className="w-full bg-neutral-700 rounded-full h-2.5 mb-2 relative overflow-hidden">

                                    <div 

                                        className="bg-gradient-to-r from-blue-500 to-cyan-500 h-2.5 rounded-full transition-all duration-300 ease-out"

                                        style={{ width: `${Percent}%` }}

                                    ></div>

                                    {Percent > 0 && Percent < 100 && (

                                        <div className="absolute top-0 left-0 w-full h-full animate-pulse">

                                        <div 

                                            className="bg-white/20 h-full w-10 -skew-x-12 animate-shimmer"

                                            style={{ 

                                            animationDuration: Percent > 80 ? '1s' : '2s',

                                            opacity: Percent > 80 ? 0.3 : 0.2 

                                            }}

                                        ></div>

                                        </div>

                                    )}

                                    </div>

                                    

                                    <div className="flex justify-between items-center">

                                    <p className="text-neutral-400 text-xs">

                                        {uploadPhase === 'compressing' ? 'This may take a few minutes for large videos...' : 

                                        uploadPhase === 'uploading_to_cdn' ? 'Finalizing upload...' : 

                                        uploadPhase === 'processing' ? 'Processing your file...' : 'Uploading...'}

                                    </p>

                                    <button 

                                        className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded-full transition-colors disabled:opacity-50"

                                        onClick={handleCancelUpload}

                                        disabled={uploadPhase === 'complete'}

                                    >

                                        Cancel

                                    </button>

                                    </div>

                                </motion.div>

                                )}



                            {uploadStatus === 'success' && (

                                <motion.div 

                                    initial={{ opacity: 0, scale: 0.9 }}

                                    animate={{ opacity: 1, scale: 1 }}

                                    className="bg-green-500/10 border border-green-500/30 rounded-xl p-4 mb-6"

                                >

                                    <div className="flex items-center justify-center">

                                        <svg className="w-6 h-6 mr-2 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">

                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />

                                        </svg>

                                        <span className="text-green-400 font-medium">Upload successful!</span>

                                    </div>

                                </motion.div>

                            )}



                            {error && (

                                <motion.div 

                                    initial={{ opacity: 0, y: -10 }}

                                    animate={{ opacity: 1, y: 0 }}

                                    className="bg-red-500/10 border border-red-500/30 rounded-lg p-3 mb-4"

                                >

                                    <p className="text-red-400 text-sm">{error}</p>

                                </motion.div>

                            )}



                            <div className="space-y-4 mb-6">

                                <div>

                                    <label className="block text-sm font-medium text-neutral-300 mb-2">Title *</label>

                                    <input 

                                        type="text" 

                                        className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent placeholder-neutral-500"

                                        placeholder="Enter a compelling title..."

                                        value={PostDetail.heading}

                                        name='heading'

                                        onChange={handleFileChange}

                                        disabled={uploadStatus === 'uploading'}

                                    />

                                </div>

                                <div>

                                    <label className="block text-sm font-medium text-neutral-300 mb-2">Description</label>

                                    <textarea 

                                        className="w-full bg-neutral-800 border border-neutral-700 rounded-xl px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent placeholder-neutral-500 resize-none"

                                        placeholder="Describe your content..."

                                        rows="4"

                                        name='description'

                                        value={PostDetail.description}

                                        onChange={handleFileChange}

                                        disabled={uploadStatus === 'uploading'}

                                    />

                                </div>

                                <div>

                                    <label className="block text-sm font-medium text-neutral-300 mb-2">Visibility *</label>

                                    <select 

                                        className='w-full bg-neutral-800 border-neutral-700 py-3 px-4 rounded-xl text-white cursor-pointer focus:ring-2 focus:ring-blue-500 focus:border-transparent'

                                        onChange={(e) => setPostDetail({...PostDetail , visibility: e.target.value})}

                                        value={PostDetail.visibility}

                                        disabled={uploadStatus === 'uploading'}

                                    >

                                        <option value="">Select Post status</option>

                                        <option value="public">Public</option>

                                        <option value="peers">Peers Only</option>

                                    </select>

                                </div>

                            </div>



                            <div className='flex flex-col sm:flex-row gap-3 justify-between'>

                                <button 

                                    className='px-6 py-3 bg-neutral-700 hover:bg-neutral-600 text-white font-medium rounded-full transition-colors w-full sm:w-auto'

                                    onClick={() => navigateTo(1)}

                                    disabled={uploadStatus === 'uploading'}

                                >

                                    Back

                                </button>

                                <div className="flex flex-col sm:flex-row gap-3">

                                    <motion.button 

                                        whileHover={{ scale: uploadStatus !== 'uploading' ? 1.02 : 1 }}

                                        whileTap={{ scale: uploadStatus !== 'uploading' ? 0.98 : 1 }}

                                        className={`px-8 py-3 rounded-full font-semibold transition-all duration-300 w-full sm:w-auto flex items-center justify-center gap-2 ${

                                            uploadStatus === 'uploading' 

                                                ? 'bg-blue-600 cursor-not-allowed' 

                                                : 'bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600'

                                        }`}

                                        onClick={handleSubmit}

                                        disabled={uploadStatus === 'uploading' || !PostDetail.heading.trim() || !PostDetail.visibility}

                                    >

                                        {uploadStatus === 'uploading' ? (

                                            <>

                                                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>

                                                Uploading...

                                            </>

                                        ) : uploadStatus === 'success' ? (

                                            'Posted!'

                                        ) : (

                                            'Share Now'

                                        )}

                                    </motion.button>

                                </div>

                            </div>

                        </motion.div>

                    )}

                </AnimatePresence>

            </motion.div>

        </div>

    )

}



export default Post








































const express = require('express');

const multer = require('multer');

const cloudinary = require('../CloudinaryStorage/cloudinary');

const User = require('../Db/User');

const Posts = require('../Db/UserPost');

const authenticate = require('../AuthVerify/AuthMiddleware')



const userSocketMap = require('../SocketConnection/socketMap');

const { getIo } = require('../SocketConnection/socketInstance');



const fs = require("fs");

const path = require("path");

const ffmpeg = require("fluent-ffmpeg");

const ffmpegPath = require("ffmpeg-static");



ffmpeg.setFfmpegPath(ffmpegPath);



const Router = express.Router();

const storage = multer.diskStorage({});

const upload = multer({ storage });





Router.post('/userdetail', upload.none(), async (req, res) => {

    const { firstName, lastName, dob, gender, education, Uid, FUid } = req.body;



    if (!firstName || !lastName || !dob || !gender || !education || !Uid || !FUid) {

        return res.json({ ok: false, message: "All fields are required" });

    }



    await User.findOne({ firebaseUid: FUid }).lean().then((existingUser) => {

        if (existingUser) {

            return res.json({ ok: false, message: "User already exists" });

        }

    });



    try {

        let educationData;

        try {

            educationData = typeof education === 'string' ? JSON.parse(education) : education;

        } catch (e) {

            educationData = education;

        }



        const user = new User({

            firstName: firstName,

            lastName: lastName,

            dob,

            gender,

            education: educationData,

            Uid,

            firebaseUid: FUid,

            UserProfile: {

                heading: "Hey there! I am using StudyVerse.",

                description: "",

                avatar: { url: "", publicId: "" }

            }

        });



        await user.save();



        res.json({ ok: true, message: "User created successfully", user });

    } catch (error) {

        console.error("Error creating user:", error);

        res.json({ ok: false, message: error.message || "Internal server error" });

    }

});



Router.post('/profile', upload.single('image'), async (req, res) => {

    const { bio, FUid, username } = req.body;



    if (!FUid || !username) {

        return res.status(400).json({ message: "Username are required", code: "MISSING_FIELDS" });

    }



    try {

        const usernameTaken = await User.findOne({ username, firebaseUid: { $ne: FUid } });

        if (usernameTaken) {

            return res.status(400).json({ message: "Username is already taken", code: "USERNAME_TAKEN" });

        }



        const data = {

            username,

            "UserProfile.description": bio,

        }



         if (req.file) {

            const uploadResult = await cloudinary.uploader.upload(req.file.path, {

                folder: "studyverse/profiles",

            });



            data["UserProfile.avatar"] = {

                url: uploadResult.secure_url,

                publicId: uploadResult.public_id,

            };

        }



        const updatedUser = await User.findOneAndUpdate(

            { firebaseUid: FUid },

            data,

            { new: true }

        );



        if (!updatedUser) {

            return res.status(404).json({ message: "User not found", code: "USER_NOT_FOUND" });

        }



        res.json({ message: "Profile updated successfully", code: "PROFILE_UPDATED", user: updatedUser });

    } catch (err) {

        console.error("Error updating profile:", err);

        res.status(500).json({ message: "Internal server error", code: "INTERNAL_SERVER_ERROR" });

    }

});



Router.get('/friend/username/:userName' , async (req, res) => {

    try{

        const { userName } = req.params;

        if(!userName) {

            return res.status(400).json({ok: false, message: "Missing Requirment" });

        }



        User.findOne({ username: userName}).lean().then((user) => {

            if(user){

                return res.status(200).json({ok: true, user})

            }else {

                return res.status(404).json({ok: false, message: "User Not Found"})

            }

        })



    }catch(err){

        console.error("Somthing Wrong" , err);

        res.status(500).json({ok: false, message: err.message});

    }

})



Router.get('/profile/:FUid' , async (req , res) => {

    const { FUid } = req.params;



    try{

        const userProfile = await User.findOne({ firebaseUid: FUid });

        if(userProfile){

            return res.json({ message: "User profile fetched successfully", userProfile });

        }else{

            return res.json({ message: "User Not Found" });

        }

    }catch(err){

        console.error("Error fetching user profile:", err);

        res.status(500).json({ message: "Internal server error" });

    }

});





// Router.post('/posts/:Fid', upload.single('image'), async (req, res) => {

//     try{

//         const { Fid } = req.params;

//         const { heading, description } = req.body;



//         if(!heading || !description || !Fid){

//             return res.status(400).json({ message: "All fields required"});

//         }



//         const MongoId = await User.findOne({ firebaseUid: Fid });



//         if(!MongoId){

//             return res.status(404).json({ message:"User not Found from the user" });

//         }



//         const uploadFile = await cloudinary.uploader.upload(req.file.path, {

//             folder: "studyverse/posts",

//             resource_type: req.file.mimetype === "application/pdf" ? "raw" : "auto",

//         });



//         const newPost = await Posts.create({

//             author: MongoId._id,

//             heading,

//             description,

//             files: {

//                 url: uploadFile.secure_url,

//                 publicId: uploadFile.public_id,

//                 type: uploadFile.resource_type,

//             },

//         })



//         if(newPost) {

//             return res.json({ message: "Content Posted Successfully" , newPost });

//         }



//     }catch(err){

//         res.status(500).json({ message: "Because of Some reason content is not posted. Please Try again" });

//         console.log("Error: ", err);

//     }

// })





// Router.post("/posts/:Fid", upload.single("image"), async (req, res) => {

//   try {

//     const { Fid } = req.params;

//     const { heading, description, visibility, contentType } = req.body;



//     if (!heading || !description || !Fid) {

//       return res.status(400).json({ message: "All fields required" });

//     }



//     const MongoId = await User.findOne({ firebaseUid: Fid });

//     if (!MongoId) {

//       return res.status(404).json({ message: "User not Found from the user" });

//     }



//     let filePath = req.file.path;



//     const fileSizeInMB = req.file.size / (1024 * 1024);

//     if (req.file.mimetype.startsWith("video/") && fileSizeInMB > 70) {

//     console.log("âš¡ Large video detected, compressing...");

//     console.log(`Original size: ${fileSizeInMB.toFixed(2)} MB`);



//     const uploadsDir = path.join(__dirname, "../uploads");

//     if (!fs.existsSync(uploadsDir)) {

//         fs.mkdirSync(uploadsDir, { recursive: true });

//     }



//     const compressedPath = path.join(

//         uploadsDir,

//         `compressed-${Date.now()}.mp4`

//     );



//     await new Promise((resolve, reject) => {

//         ffmpeg(filePath)

//         .videoCodec("libx264")

//         .size("?x720")

//         .outputOptions(["-crf 28"])

//         .on("end", () => {

//             const stats = fs.statSync(compressedPath);

//             const compressedSizeMB = stats.size / (1024 * 1024);



//             console.log(`âœ… Compression finished: ${compressedPath}`);

//             console.log(

//             `Compressed size: ${compressedSizeMB.toFixed(

//                 2

//             )} MB (Saved: ${(fileSizeInMB - compressedSizeMB).toFixed(2)} MB)`

//             );



//             filePath = compressedPath;

//             resolve();

//         })

//         .on("error", (err) => reject(err))

//         .save(compressedPath);

//     });

//     }



//     const uploadFile = await cloudinary.uploader.upload(filePath, {

//       folder: "studyverse/posts",

//       resource_type:

//         req.file.mimetype === "application/pdf" ? "raw" : "auto",

//         use_filename: true,

//         unique_filename: false

//     });



//     fs.unlinkSync(filePath);



//     const newPost = await Posts.create({

//       author: MongoId._id,

//       heading,

//       description,

//       files: {

//         url: uploadFile.secure_url,

//         publicId: uploadFile.public_id,

//         type: uploadFile.resource_type,

//       },

//       visibility: visibility,

//       contentType: contentType,

//     });



//     return res.json({

//       message: "Content Posted Successfully",

//       newPost,

//     });



//   } catch (err) {

//     res.status(500).json({

//       message:

//         "Because of Some reason content is not posted. Please Try again",

//     });

//     console.log("Error: ", err);

//   }

// });





Router.post("/posts/:Fid", upload.single("image"), async (req, res) => {

  let compressionCleanup = null;

  

  try {

    const { Fid } = req.params;

    const { heading, description, visibility, contentType } = req.body;

    const io = getIo();



    if (!heading?.trim() || !Fid) {

      return res.status(400).json({ message: "Title and user ID are required" });

    }



    if (!req.file) {

      return res.status(400).json({ message: "File is required" });

    }



    const MongoId = await User.findOne({ firebaseUid: Fid });

    if (!MongoId) {

      if (req.file.path) fs.unlinkSync(req.file.path);

      return res.status(404).json({ message: "User not found" });

    }



    let filePath = req.file.path;

    const fileSizeInMB = req.file.size / (1024 * 1024);



    const userId = MongoId._id.toString();

    const recipientSocketId = userSocketMap.get(userId);



    // Send proper 0-100% progress

    const emitProgress = (percent, phase, message = '') => {

      if (recipientSocketId) {

        io.to(recipientSocketId).emit('uploadProgress', {

          progress: Math.min(percent, 100), // Ensure never over 100%

          phase: phase,

          message: message

        });

        console.log(`ðŸ“¡ Emitting progress: ${percent}% (${phase})`);

      }

    };



    // Initial processing

    emitProgress(10, 'processing', 'File uploaded, starting processing...');



    if (req.file.mimetype.startsWith("video/") && fileSizeInMB > 40) {

      console.log(`ðŸŽ¥ Compressing ${fileSizeInMB.toFixed(2)}MB video for user ${Fid}`);

      

      const uploadsDir = path.join(__dirname, "../uploads");

      if (!fs.existsSync(uploadsDir)) {

        fs.mkdirSync(uploadsDir, { recursive: true });

      }



      const compressedPath = path.join(uploadsDir, `compressed-${Date.now()}-${Fid}.mp4`);

      

      await new Promise((resolve, reject) => {

        let lastProgress = 0;

        

        const ffmpegProcess = ffmpeg(filePath)

          .videoCodec("libx264")

          .audioCodec("aac")

          .size("?x720")

          .outputOptions([

            "-crf 28",

            "-preset medium",

            "-movflags +faststart",

            "-maxrate 2M",

            "-bufsize 4M"

          ])

          .on("progress", (progress) => {

            const percent = Math.min(Math.floor(progress.percent || 0), 100);

            

            // Only emit if progress actually changed

            if (percent > lastProgress && percent <= 100) {

              lastProgress = percent;

              // Map compression progress to 20-70% range

              const overallProgress = 20 + (percent * 0.5);

              

              emitProgress(

                overallProgress, 

                'compressing', 

                `Compressing video: ${percent}%`

              );

            }

          })

          .on("end", () => {

            const stats = fs.statSync(compressedPath);

            const compressedSizeMB = stats.size / (1024 * 1024);

            

            console.log(`âœ… Compression completed: ${compressedSizeMB.toFixed(2)}MB (${((fileSizeInMB - compressedSizeMB)/fileSizeInMB*100).toFixed(1)}% reduction)`);

            

            // Clean up original file

            if (fs.existsSync(filePath)) {

              fs.unlinkSync(filePath);

            }

            

            filePath = compressedPath;

            compressionCleanup = compressedPath;

            

            emitProgress(70, 'uploading_to_cdn', 'Video compressed, uploading to CDN...');

            resolve();

          })

          .on("error", (err) => {

            console.error('âŒ Compression failed:', err);

            reject(new Error(`Video compression failed: ${err.message}`));

          })

          .on('codecData', (data) => {

            console.log(`ðŸ“Š Input: ${data.format} ${data.video_details}`);

            emitProgress(15, 'analyzing', `Analyzing video: ${data.format}`);

          })

          .save(compressedPath);



        // Compression timeout (10 minutes)

        const timeout = setTimeout(() => {

          ffmpegProcess.kill('SIGTERM');

          reject(new Error('Compression timeout - video too long or complex'));

        }, 600000);



        ffmpegProcess.on('end', () => clearTimeout(timeout));

        ffmpegProcess.on('error', () => clearTimeout(timeout));

      });

    } else {

      // Skip compression for small files or non-videos

      emitProgress(50, 'uploading_to_cdn', 'Uploading to CDN...');

    }



    // Upload to Cloudinary - simulate progress

    emitProgress(70, 'uploading_to_cdn', 'Uploading to cloud storage...');

    

    // Simulate Cloudinary upload progress

    let cloudinaryProgress = 70;

    const progressInterval = setInterval(() => {

      if (cloudinaryProgress < 95) {

        cloudinaryProgress += 5;

        emitProgress(cloudinaryProgress, 'uploading_to_cdn', 'Uploading to cloud storage...');

      } else {

        clearInterval(progressInterval);

      }

    }, 1000);



    const uploadFile = await cloudinary.uploader.upload(filePath, {

      folder: "studyverse/posts",

      resource_type: req.file.mimetype === "application/pdf" ? "raw" : "auto",

      use_filename: true,

      unique_filename: true,

      quality: 'auto',

      fetch_format: 'auto'

    });



    clearInterval(progressInterval);



    // Clean up local files

    if (fs.existsSync(filePath)) {

      fs.unlinkSync(filePath);

    }

    if (compressionCleanup && fs.existsSync(compressionCleanup)) {

      fs.unlinkSync(compressionCleanup);

    }



    // Create post in database

    const newPost = await Posts.create({

      author: MongoId._id,

      heading: heading.trim(),

      description: description?.trim() || "",

      files: {

        url: uploadFile.secure_url,

        publicId: uploadFile.public_id,

        type: uploadFile.resource_type,

        format: uploadFile.format,

        bytes: uploadFile.bytes,

        duration: uploadFile.duration

      },

      visibility: visibility || 'public',

      contentType: contentType || 'post',

    });



    // Final success

    emitProgress(100, 'complete', 'Upload completed successfully!');



    return res.status(201).json({

      message: "Content posted successfully",

      newPost,

      uploadFile: {

        url: uploadFile.secure_url,

        format: uploadFile.format,

        duration: uploadFile.duration

      }

    });



  } catch (err) {

    // Comprehensive error handling and cleanup

    console.error('ðŸš¨ Upload error:', err);

    

    // Clean up any temporary files

    try {

      if (req.file?.path && fs.existsSync(req.file.path)) {

        fs.unlinkSync(req.file.path);

      }

      if (compressionCleanup && fs.existsSync(compressionCleanup)) {

        fs.unlinkSync(compressionCleanup);

      }

    } catch (cleanupErr) {

      console.error('Cleanup error:', cleanupErr);

    }

    

    // Notify client

    const userId = await User.findOne({ firebaseUid: req.params.Fid });

    if (userId) {

      const recipientSocketId = userSocketMap.get(userId._id.toString());

      if (recipientSocketId) {

        io.to(recipientSocketId).emit('uploadProgress', { 

          progress: 0, 

          phase: 'error',

          message: err.message || 'Upload failed',

          error: true

        });

      }

    }

    

    // Appropriate status codes

    if (err.message.includes('timeout')) {

      return res.status(408).json({ message: "Upload timeout - file too large" });

    } else if (err.message.includes('compression')) {

      return res.status(422).json({ message: "Video processing failed" });

    } else if (err.message.includes('User not found')) {

      return res.status(404).json({ message: "User not found" });

    }

    

    return res.status(500).json({

      message: "Upload failed. Please try again with a smaller file.",

      error: process.env.NODE_ENV === 'development' ? err.message : undefined

    });

  }

});



// Router.get('/search', async (req, res) => {

//     const { query, uid } = req.query;



//     try {

//         const user = await User.findById(uid);

//         if(!user) return res.status(404).json({message: "User Not found"});

        

//         const users = await User.find({

//             $or: [

//                 { username: { $regex: query, $options: "i" } },

//             ]

//         })

//         .select('firstName lastName education firebaseUid username UserProfile')



//         const Notes = await Posts.find({

//             contentType: 'note',

//             $or: [

//                 { 

//                     visibility: "public",

//                     $or: [

//                         { heading: { $regex: query, $options: "i" } },

//                         { description: { $regex: query, $options: "i" } }

//                     ]

//                 },

//                 { 

//                     visibility: "peers", 

//                     author: { $in: user.connections },

//                     $or: [

//                         { heading: { $regex: query, $options: "i" } },

//                         { description: { $regex: query, $options: "i" } }

//                     ]

//                 },

//                 { 

//                     author: uid,

//                     $or: [

//                         { heading: { $regex: query, $options: "i" } },

//                         { description: { $regex: query, $options: "i" } }

//                     ]

//                 }

//             ]

//         })



//         const Lesson = await Posts.find({

//             contentType: 'lesson',

//             $or: [

//                 { heading: { $regex: query, $options: "i" } },

//                 { description: { $regex: query, $options: "i" } }

//             ]

//         })



//         res.json({ message: "Search results", users, Lesson, Notes });

//     } catch (err) {

//         console.error("Error searching users:", err);

//         res.status(500).json({ message: "Internal server error" });

//     }

// });



Router.get('/searchUser', authenticate , async (req, res) => {

    const { query } = req.query;

    const userId = req.user._id;



    const searchRegex = new RegExp(escapeRegex(query), 'i');

    const words = query.trim().split(/\s+/).filter(word => word.length > 0);



    try{

        try{

            const users = await User.find({

                $or: [

                    { 

                        $or: [

                            { firstName: { $regex: `^${query}$`, $options: 'i' } },

                            { lastName: { $regex: `^${query}$`, $options: 'i' } },

                            { username: { $regex: `^${query}$`, $options: 'i' } }

                        ]

                    },

                    { 

                        $or: [

                            { firstName: { $regex: `^${query}`, $options: 'i' } },

                            { lastName: { $regex: `^${query}`, $options: 'i' } },

                            { username: { $regex: `^${query}`, $options: 'i' } }

                        ]

                    },

                    words.length > 1 ? {

                        $and: words.map(word => ({

                            $or: [

                                { firstName: { $regex: word, $options: 'i' } },

                                { lastName: { $regex: word, $options: 'i' } },

                                { username: { $regex: word, $options: 'i' } }

                            ]

                        }))

                    } : {},

                    {

                        $or: [

                            { firstName: searchRegex },

                            { lastName: searchRegex },

                            { username: searchRegex },

                        ]

                    },

                    ...generatePartialMatches(words, ['firstName', 'lastName', 'username'])

                ].filter(condition => Object.keys(condition).length > 0)

            })

            .select("firstName lastName education firebaseUid username UserProfile")

            .lean()

            return res.json({users:users});



        }catch(err){

            console.log("Somthing error", err.message);

            const users = await User.find({

                $or: [

                    { firstName: searchRegex },

                    { lastName: searchRegex },

                    { username: searchRegex }

                ]

            })

            .select("firstName lastName education firebaseUid username UserProfile")

            .lean()

            

           return res.json({users:users});

        }

    }catch(err){

        console.log("Error", err.message);

    }

});





Router.get('/search', authenticate , async (req, res) => {

    const { query, uid, page = 1, limit = 10 } = req.query;



    try {

        const user = await User.findById(uid).lean();

        if (!user) {

            return res.status(404).json({ message: "User not found" });

        }



        const pageNum = Math.max(1, parseInt(page));

        const limitNum = Math.min(50, parseInt(limit));

        const skip = (pageNum - 1) * limitNum;



        const searchResults = await performEnhancedSearch(query, uid, user, pageNum, limitNum, skip);

        

        res.json(searchResults);



    } catch (err) {

        console.error("Error searching:", err);

        const user = await User.findById(uid).lean();

        if (!user) {

            return res.status(404).json({ message: "User not found" });

        }

        const fallbackResults = await performRegexSearch(query, uid, user, pageNum, limitNum, skip);

        res.json(fallbackResults);

    }

});



// Enhanced search function with multiple strategies

async function performEnhancedSearch(query, uid, user, pageNum, limitNum, skip) {

    const searchRegex = new RegExp(escapeRegex(query), 'i');

    const words = query.trim().split(/\s+/).filter(word => word.length > 0);

    

    const searchPatterns = generateSearchPatterns(query, words);

    

    const [users, notes, lessons, totalCounts] = await Promise.all([

        User.find({

            $or: [

                { 

                    $or: [

                        { firstName: { $regex: `^${query}$`, $options: 'i' } },

                        { lastName: { $regex: `^${query}$`, $options: 'i' } },

                        { username: { $regex: `^${query}$`, $options: 'i' } }

                    ]

                },

                { 

                    $or: [

                        { firstName: { $regex: `^${query}`, $options: 'i' } },

                        { lastName: { $regex: `^${query}`, $options: 'i' } },

                        { username: { $regex: `^${query}`, $options: 'i' } }

                    ]

                },

                words.length > 1 ? {

                    $and: words.map(word => ({

                        $or: [

                            { firstName: { $regex: word, $options: 'i' } },

                            { lastName: { $regex: word, $options: 'i' } },

                            { username: { $regex: word, $options: 'i' } }

                        ]

                    }))

                } : {},

                {

                    $or: [

                        { firstName: searchRegex },

                        { lastName: searchRegex },

                        { username: searchRegex },

                        { "education.standard": searchRegex },

                        { "education.degree": searchRegex },

                        { "education.field": searchRegex },

                        { "education.institute": searchRegex }

                    ]

                },

                ...generatePartialMatches(words, ['firstName', 'lastName', 'username'])

            ].filter(condition => Object.keys(condition).length > 0)

        })

        .select("firstName lastName education firebaseUid username UserProfile")

        .limit(limitNum)

        .skip(skip)

        .lean(),



        Posts.find({

            contentType: "note",

            $or: [

                // Exact title match

                { heading: { $regex: `^${query}$`, $options: 'i' } },

                // Starts with query

                { heading: { $regex: `^${query}`, $options: 'i' } },

                // Contains all words in title or description

                words.length > 1 ? {

                    $and: words.map(word => ({

                        $or: [

                            { heading: { $regex: word, $options: 'i' } },

                            { description: { $regex: word, $options: 'i' } }

                        ]

                    }))

                } : {},

                // Contains any word

                {

                    $or: [

                        { heading: searchRegex },

                        { description: searchRegex }

                    ]

                }

            ].filter(condition => Object.keys(condition).length > 0),

            $or: [

                { visibility: "public" },

                {

                    visibility: "peers",

                    author: { $in: user.connections }

                },

                { author: uid }

            ]

        })

        .populate('author', 'firstName lastName username')

        .limit(limitNum)

        .skip(skip)

        .lean(),



        // Enhanced Lessons search

        Posts.find({

            contentType: "lesson",

            $or: [

                // Exact title match

                { heading: { $regex: `^${query}$`, $options: 'i' } },

                // Starts with query

                { heading: { $regex: `^${query}`, $options: 'i' } },

                // Contains all words

                words.length > 1 ? {

                    $and: words.map(word => ({

                        $or: [

                            { heading: { $regex: word, $options: 'i' } },

                            { description: { $regex: word, $options: 'i' } }

                        ]

                    }))

                } : {},

                // Contains any word

                {

                    $or: [

                        { heading: searchRegex },

                        { description: searchRegex }

                    ]

                }

            ].filter(condition => Object.keys(condition).length > 0)

        })

        .populate('author', 'firstName lastName username')

        .limit(limitNum)

        .skip(skip)

        .lean(),



        // Count queries

        Promise.all([

            User.countDocuments({

                $or: [

                    { firstName: searchRegex },

                    { lastName: searchRegex },

                    { username: searchRegex },

                    { "education.standard": searchRegex },

                    { "education.degree": searchRegex },

                    { "education.field": searchRegex },

                    { "education.institute": searchRegex }

                ]

            }),

            Posts.countDocuments({

                contentType: "note",

                $or: [

                    { heading: searchRegex },

                    { description: searchRegex }

                ],

                $or: [

                    { visibility: "public" },

                    {

                        visibility: "peers",

                        author: { $in: user.connections }

                    },

                    { author: uid }

                ]

            }),

            Posts.countDocuments({

                contentType: "lesson",

                $or: [

                    { heading: searchRegex },

                    { description: searchRegex }

                ]

            })

        ])

    ]);



    const [totalUsers, totalNotes, totalLessons] = totalCounts;



    return {

        ok: true,

        message: "Search results",

        users,

        notes,

        lessons,

        pagination: {

            page: pageNum,

            limit: limitNum,

            totalUsers,

            totalNotes,

            totalLessons,

            hasMore: {

                users: users.length === limitNum && totalUsers > skip + users.length,

                notes: notes.length === limitNum && totalNotes > skip + notes.length,

                lessons: lessons.length === limitNum && totalLessons > skip + lessons.length

            }

        }

    };

}



// Helper functions

function escapeRegex(text) {

    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');

}



function generateSearchPatterns(query, words) {

    const patterns = [];

    

    // Exact match

    patterns.push({ $regex: `^${query}$`, $options: 'i' });

    

    // Starts with

    patterns.push({ $regex: `^${query}`, $options: 'i' });

    

    // Contains

    patterns.push({ $regex: query, $options: 'i' });

    

    // For multi-word queries, create patterns for each word

    if (words.length > 1) {

        words.forEach(word => {

            if (word.length > 2) {

                patterns.push({ $regex: word, $options: 'i' });

            }

        });

    }

    

    return patterns;

}



function generatePartialMatches(words, fields) {

    const partialMatches = [];

    

    words.forEach(word => {

        if (word.length > 2) {

            // Match words that contain parts of the search term

            for (let i = 3; i <= word.length; i++) {

                const partial = word.substring(0, i);

                fields.forEach(field => {

                    partialMatches.push({

                        [field]: { $regex: partial, $options: 'i' }

                    });

                });

            }

        }

    });

    

    return partialMatches;

}



// Basic regex search fallback

async function performRegexSearch(query, uid, user, pageNum, limitNum, skip) {

    const searchRegex = new RegExp(escapeRegex(query), 'i');

    

    const [users, notes, lessons] = await Promise.all([

        User.find({

            $or: [

                { firstName: searchRegex },

                { lastName: searchRegex },

                { username: searchRegex }

            ]

        })

        .select("firstName lastName education firebaseUid username UserProfile")

        .limit(limitNum)

        .skip(skip)

        .lean(),



        Posts.find({

            contentType: "note",

            $or: [

                { heading: searchRegex },

                { description: searchRegex }

            ],

            $or: [

                { visibility: "public" },

                {

                    visibility: "peers",

                    author: { $in: user.connections }

                },

                { author: uid }

            ]

        })

        .populate('author', 'firstName lastName username')

        .limit(limitNum)

        .skip(skip)

        .lean(),



        Posts.find({

            contentType: "lesson",

            $or: [

                { heading: searchRegex },

                { description: searchRegex }

            ]

        })

        .populate('author', 'firstName lastName username')

        .limit(limitNum)

        .skip(skip)

        .lean()

    ]);



    return {

        ok: true,

        message: "Search results (basic)",

        users,

        notes,

        lessons,

        pagination: {

            page: pageNum,

            limit: limitNum,

            hasMore: {

                users: users.length === limitNum,

                notes: notes.length === limitNum,

                lessons: lessons.length === limitNum

            }

        }

    };

}



Router.put('/profile/update/:FUid', upload.single('image'), async (req, res) => {

    const { FUid } = req.params;

    const { firstName, lastName, description, heading, gender, dob, education } = req.body;



    if (!FUid) {

        return res.status(400).json({ message: "User ID is required", code: "MISSING_USER_ID" });

    }



    let educationData;

    try {

        educationData = typeof education === 'string' ? JSON.parse(education) : education;

    } catch (e) {

        educationData = education;

    }



    try {

        let updateData = {

            firstName,

            lastName,

            dob,

            gender,

            education: educationData,

            "UserProfile.description": description,

            "UserProfile.heading": heading,

        };



        if (req.file) {

            const uploadResult = await cloudinary.uploader.upload(req.file.path, {

                folder: "studyverse/profiles",

            });



            updateData["UserProfile.avatar"] = {

                url: uploadResult.secure_url,

                publicId: uploadResult.public_id,

            };

        }



        const updatedProfile = await User.findOneAndUpdate(

            { firebaseUid: FUid },

            updateData,

            { new: true }

        );



        if (!updatedProfile) {

            return res.status(404).json({ message: "User not found", code: "USER_NOT_FOUND" });

        }



        res.json({ 

            ok: true, 

            message: "Profile updated successfully", 

            user: updatedProfile 

        });



    } catch (err) {

        console.error("Error updating profile:", err);

        res.status(500).json({ 

            ok: false,

            message: "Internal server error", 

            code: "INTERNAL_SERVER_ERROR" 

        });

    }

});



Router.get('/setting/:id' , async (req, res) => {

    const { id } = req.params;



    if(!id) {

        return res.status(404).json({message : "User not found, Please refresh the page"})

    }



    try{

        const UserSetting = await User.findById(id);



        if(!UserSetting) {

            return res.status(404).json({message: "User not found, Please refresh the page or try again"});

        }



        res.json({ok: true , settings: UserSetting.setting});



    }catch(err){

        console.log(err.message);

        res.status(500).json({message: "Server is busy"});

    }

});



Router.post('/settingsUpdated/:id', async (req, res) => {

    const { id } = req.params;

    const settings  = req.body;



    if(!id) {

        return res.status(404).json({message : "User not found, Please refresh the page"})

    }



    if(!settings) {

        return res.status(404).json({message: "Changes found"});

    }



    try{

       const UserSettings = await User.findOneAndUpdate(

            { _id: id },

            { setting: settings},

            { new: true },

        )



        if(!UserSettings){

            return res.status(404).json({message: "User not found"});

        }



        return res.json({ok : true , message: "Setting updated successfully"})

    }catch(err){

        res.status(500).json({message: err.message});

        console.log(err.message);

    }

})



Router.get('/notification/:Uid' , async (req, res) => {



    const { Uid } = req.params;



      try{

        const GetNotification = await User.findOne({ Uid })

        .select("notification._id setting notification.user notification.Type notification.whichPost")

        .populate("notification.user" , "firstName lastName UserProfile.avatar")

        .populate("notification.whichPost", "files.url")

    

        if(!GetNotification){

          return res.status(404).json({message: "User Not Found"});

        }



        const {setting}  = GetNotification;



        let filterNotification = GetNotification.notification.filter((notify) => {

            if(notify.Type === 'like' && !setting.showLikeNotifications) return false;

            if(notify.Type === 'comment' && !setting.showCommentNotifications) return false;

            return true;

        })        



        const notification = filterNotification.map((notify) => ({

            _id: notify._id,

            type: notify.Type,

            message: `${notify.Type === 'comment' ? `${notify.user.firstName} commented on your post` : `Your post Liked by the ${notify.user.firstName} ${notify.user.lastName}` }`,

            sender: {

                _id: notify.user._id,

                firstName: notify.user.firstName,

                lastName: notify.user.lastName,

                avatar: notify?.whichPost?.files?.url,

            },

            comment: notify?.comment || '',

            createdAt: new Date(),

            read: false

        }))

    

        res.json({ok: true , notification});

      }catch(err) {

        console.log("Notificaion" ,err.message);

      }

})



Router.get('/getConnections', async (req, res) => {

    const  ids = req.query.ids.split(',');



    try{

        if(ids.length < 2 ) {

            return res.status(404).json({message: " Missing requirements" });

        }

        const User1 = await User.findById(ids[0])

            .select("firstName lastName connections MyConnections connectionRequests");



        const User2 = await User.findById(ids[1])

            .select("firstName lastName connections MyConnections connectionRequests");



        if(!User1 || !User2){

            return res.status(404).json({message: "User Not Found"});

        }



        return res.json({ok: true, currentUserData: User1, OtherUserData: User2});



    }catch(err){

        console.log(err.message);

        res.status(500).json({ ok: false, message: "Internal server error" });

    }

})



Router.get('/:Uid/notifications', async (req, res) => {

  try {

    const { Uid } = req.params;



    if (!Uid) {

      return res.status(400).json({ ok: false, message: "Uid is required" });

    }



    const user = await User.findOne({ Uid })

      .populate("connectionRequests", "firstName lastName UserProfile.avatar");



    if (!user) {

      return res.status(404).json({ ok: false, message: "User not found" });

    }



    const notifications = user.connectionRequests.map(reqUser => ({

      _id: reqUser._id,

      type: "peer_request",

      message: `You have a new peer request from ${reqUser.firstName}`,

      sender: {

        _id: reqUser._id,

        firstName: reqUser.firstName,

        lastName: reqUser.lastName,

        avatar: reqUser?.UserProfile?.avatar?.url || null

      },

      createdAt: new Date(),

      read: false

    }));



    return res.status(200).json({

      ok: true,

      notifications

    });

  } catch (err) {

    console.error("Error fetching notifications:", err);

    res.status(500).json({ ok: false, message: "Internal server error" });

  }

});





Router.post('/notification/:fromId' , async (req, res) => {

    const { fromId } = req.params;

    const { type, toId } = req.body;



   try{

        if(!fromId || !type) {

        return res.status(404).json({message: "Missing Requirment"});

    }



    const newNotification = {

        user: fromId,

        Type: type,

    }



    const setNotification = await User.findByIdAndUpdate(

        toId,

        { $push : { notification: newNotification }},

        {new: true}

    )



    if(!setNotification){

        return res.status(404).json({message: "User Not Found"});

    }



   }catch(err){

        console.log(err.message);

        res.json({message: err.message});

   }

})



Router.post('/messages/fileupload' , upload.single('file') , async (req, res) => {



    try{

        if (!req.file) {

            return res.status(404).json({ message: "No file uploaded", code: "NO_FILE_UPLOADED" });

        }



        const uploadFile = await cloudinary.uploader.upload(req.file.path, {

            folder: "studyverse/posts",

            resource_type: req.file.mimetype === "application/pdf" ? "raw" : "auto",

        });



        return res.json({ok: true, url: uploadFile.secure_url, publicId: uploadFile.public_id, type: uploadFile.resource_type })



    }catch(err){

        console.log(err.message);

    }

})



Router.get('/userConnections/:id', async (req, res) => {

    const { id } = req.params;



    if (!id) {

        return res.status(400).json({ message: "User ID is required" });

    }



    try {

        const user = await User.findById(id)

            .populate({

                path: "connections",

                select: "firstName lastName username education UserProfile.avatar"

            })

            .populate({

                path: "MyConnections",

                select: "firstName lastName username education UserProfile.avatar"

            });



        if (!user) {

            return res.status(404).json({ message: "User not found" });

        }



        res.json({

            ok: true,

            Connections: user.connections,

            ConnectionNetWork: user.MyConnections

        });

    } catch (err) {

        console.error(err.message);

        res.status(500).json({ message: "Server error" });

    }

});





module.exports = Router;